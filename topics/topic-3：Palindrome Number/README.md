
# 回文数

> 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>
 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。


示例 1：
```
输入：x = 121
 输出：true
```

示例 2：
```
 输入：x = -121
 输出：false
 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```


示例 3：
```
 输入：x = 10
 输出：false
 解释：从右向左读, 为 01 。因此它不是一个回文数。
```

示例 4：
```
 输入：x = -101
 输出：false
```

### 思路
反转数与原数字相等，即为回文数。又考虑到过程中，我们创建的数会大于原数字。那么，只要进行一半就可以。

例如：对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，`1221 / 10 = 122`，再求出上一步结果除以 10 的余数，`122 % 10 = 2`，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，`1 * 10 + 2 = 12`，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

x数字长度为奇数
```
x: 12321->1232->123->12
rev: 0->1->12->123
```

x数字长度为偶数
```
x: 123321->12332->1233->123
rev: 0->1->12->123
```

解1:
```swift
func isPalindrome(_ x: Int) -> Bool {
    if x < 0 {
        return false
    }
    let s = String(x)
    let half = s.count / 2
    for i in 0..<s.count {
        if s[s.index(s.startIndex, offsetBy: i)] != s[s.index(s.endIndex, offsetBy: -i-1)] {
            return false
        }
        if i == half {
            break
        }
    }
    return true
}
```

解2:
```swfit
func isPalindrome(_ x: Int) -> Bool {
    if x < 0 {
        return false
    }

    var v = x
    var res = 0, l = 0
    while v != 0 {
        l = v % 10
        res = res * 10 + l
        v /= 10
    }

    return x == res
}
```
